<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2025-06-01T15:21:46+00:00</updated><id>/feed.xml</id><title type="html">Your awesome title</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Leet code 8: Chuyển đổi xâu sang số</title><link href="/leet-code/algorithm/2025/06/01/leet-code-8-string-to-integer-(atoi)/" rel="alternate" type="text/html" title="Leet code 8: Chuyển đổi xâu sang số" /><published>2025-06-01T15:08:00+00:00</published><updated>2025-06-01T15:08:00+00:00</updated><id>/leet-code/algorithm/2025/06/01/leet-code-8-string-to-integer-(atoi)</id><content type="html" xml:base="/leet-code/algorithm/2025/06/01/leet-code-8-string-to-integer-(atoi)/"><![CDATA[<p>Bài toán: Chuyển đổi xâu sang số</p>

<p><a href="https://leetcode.com/problems/string-to-integer-atoi">https://leetcode.com/problems/string-to-integer-atoi</a></p>

<p>Duyệt từ trái sang phải của xâu, qua từng ký tự</p>
<ul>
  <li>Bỏ qua các ký tự trắng ở đầu xâu, bắt đầu xử lý ở ký tự khác ký tự trắng</li>
  <li>Gặp ký tự <code class="language-plaintext highlighter-rouge">+</code> hoặc <code class="language-plaintext highlighter-rouge">-</code> thì lưu lại để biết là dương hay âm</li>
  <li>Gặp ký tự chữ bất kỳ thì dừng lại</li>
</ul>

<p>Sau 3 điều kiện trên thì sẽ đến kí tự số và bắt đầu xử lý chuyển sang số. nếu không có số nào ngay sau đó thì trả về 0 luôn</p>

<p>Integer.Max_VALUE = 2_147_483_647</p>

<p>Integer.Min_VALUE = -2_147_483_648</p>

<p>Nếu trị tuyệt đối kết quả cần trả về lớn hơn 2_147_483_647 thì ta chỉ cần xem dấu <code class="language-plaintext highlighter-rouge">+</code> hay <code class="language-plaintext highlighter-rouge">-</code> có trong xâu để trả về kết quả tương ứng là 2_147_483_647 hoặc -2_147_483_648 mà không cần tính toán tiếp, ngược lại thì trả về chính kết quả đang xét đi kèm với dấu.</p>

<p>Source code tham khảo: <a href="https://github.com/hoangdangduy/System_Patterns_Algorithm/tree/Master/Leetcode/src/_8_String_To_Integer_atoi">https://github.com/hoangdangduy/System_Patterns_Algorithm/tree/Master/Leetcode/src/_8_String_To_Integer_atoi</a></p>]]></content><author><name>hoangdd</name></author><category term="leet-code" /><category term="algorithm" /><summary type="html"><![CDATA[Bài toán: Chuyển đổi xâu sang số]]></summary></entry><entry><title type="html">Leet code 6: Chuyển đổi xâu theo dạng zigzag</title><link href="/leet-code/algorithm/2025/05/28/leet-code-6-zigzag-conversion/" rel="alternate" type="text/html" title="Leet code 6: Chuyển đổi xâu theo dạng zigzag" /><published>2025-05-28T15:28:00+00:00</published><updated>2025-05-28T15:28:00+00:00</updated><id>/leet-code/algorithm/2025/05/28/leet-code-6-zigzag-conversion</id><content type="html" xml:base="/leet-code/algorithm/2025/05/28/leet-code-6-zigzag-conversion/"><![CDATA[<p>Bài toán: Chuyển đổi xâu theo dạng zigzag</p>

<p><a href="https://leetcode.com/problems/zigzag-conversion">https://leetcode.com/problems/zigzag-conversion</a></p>

<p>Ví dụ với xâu <code class="language-plaintext highlighter-rouge">PAYPALISHIRING</code> thì ta sẽ có index như sau:</p>

<div class="container-fluid">
  <div class="row">
    <div class="col-12 col-md-8">
      <div class="table-responsive">
        <table class="table table-bordered">
          <thead>
            <tr>
              <th class="p-1 p-sm-2">Index</th>
              <th class="p-1 p-sm-2">0</th>
              <th class="p-1 p-sm-2">1</th>
              <th class="p-1 p-sm-2">2</th>
              <th class="p-1 p-sm-2">3</th>
              <th class="p-1 p-sm-2">4</th>
              <th class="p-1 p-sm-2">5</th>
              <th class="p-1 p-sm-2">6</th>
              <th class="p-1 p-sm-2">7</th>
              <th class="p-1 p-sm-2">8</th>
              <th class="p-1 p-sm-2">9</th>
              <th class="p-1 p-sm-2">10</th>
              <th class="p-1 p-sm-2">11</th>
              <th class="p-1 p-sm-2">12</th>
              <th class="p-1 p-sm-2">13</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="p-1 p-sm-2">Character</td>
              <td class="p-1 p-sm-2">P</td>
              <td class="p-1 p-sm-2">A</td>
              <td class="p-1 p-sm-2">Y</td>
              <td class="p-1 p-sm-2">P</td>
              <td class="p-1 p-sm-2">A</td>
              <td class="p-1 p-sm-2">L</td>
              <td class="p-1 p-sm-2">I</td>
              <td class="p-1 p-sm-2">S</td>
              <td class="p-1 p-sm-2">H</td>
              <td class="p-1 p-sm-2">I</td>
              <td class="p-1 p-sm-2">R</td>
              <td class="p-1 p-sm-2">I</td>
              <td class="p-1 p-sm-2">N</td>
              <td class="p-1 p-sm-2">G</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</div>

<div style="text-align: center;">
  <img src="/assets/images/leetcode/exe-6/jump.png" alt="leet_code_6_jump" class="img-fluid" />
  <p class="text-muted">Hình 1: Bước nhảy</p>
</div>

<p>Dựa theo ví dụ ta sẽ hình dung ra được n chính là số hàng sẽ được triển khai. Ứng với mỗi hàng ta sẽ tạo 1 StringBuilder để chứa các ký tự của hàng đó, tức là ta sẽ có 1 array của các StringBuilder.</p>

<p>Chúng ta sẽ tạo ra biến jump tăng/giảm current row.</p>

<p>Khi đó ta có bảng mô tả như sau:</p>
<ul>
  <li>current row = 0 thì jump = 1</li>
  <li>current row = n - 1 thì jump = -1</li>
  <li>current row = current row + jump</li>
</ul>
<div class="container-fluid">
  <div class="row">
    <div class="col-12 col-md-8">
      <div class="table-responsive">
        <table class="table table-bordered">
          <thead>
            <tr>
              <th class="p-1 p-sm-2">Index Character</th>
              <th class="p-1 p-sm-2">Character</th>
              <th class="p-1 p-sm-2">Current row</th>
              <th class="p-1 p-sm-2">Jump</th>
              <th class="p-1 p-sm-2">Index Row</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="p-1 p-sm-2">0</td>
              <td class="p-1 p-sm-2">P</td>
              <td class="p-1 p-sm-2">0</td>
              <td class="p-1 p-sm-2">1</td>
              <td class="p-1 p-sm-2">StringBuilder[0].append(P)</td>
            </tr>
            <tr>
              <td class="p-1 p-sm-2">1</td>
              <td class="p-1 p-sm-2">A</td>
              <td class="p-1 p-sm-2">1</td>
              <td class="p-1 p-sm-2">1</td>
              <td class="p-1 p-sm-2">StringBuilder[1].append(A)</td>
            </tr>
            <tr>
              <td class="p-1 p-sm-2">2</td>
              <td class="p-1 p-sm-2">Y</td>
              <td class="p-1 p-sm-2">2</td>
              <td class="p-1 p-sm-2">-1</td>
              <td class="p-1 p-sm-2">StringBuilder[2].append(Y)</td>
            </tr>
            <tr>
              <td class="p-1 p-sm-2">3</td>
              <td class="p-1 p-sm-2">P</td>
              <td class="p-1 p-sm-2">1</td>
              <td class="p-1 p-sm-2">-1</td>
              <td class="p-1 p-sm-2">StringBuilder[1].append(P)</td>
            </tr>
            <tr>
              <td class="p-1 p-sm-2">4</td>
              <td class="p-1 p-sm-2">A</td>
              <td class="p-1 p-sm-2">0</td>
              <td class="p-1 p-sm-2">1</td>
              <td class="p-1 p-sm-2">StringBuilder[0].append(A)</td>
            </tr>
            <tr>
              <td class="p-1 p-sm-2">5</td>
              <td class="p-1 p-sm-2">L</td>
              <td class="p-1 p-sm-2">1</td>
              <td class="p-1 p-sm-2">1</td>
              <td class="p-1 p-sm-2">StringBuilder[1].append(L)</td>
            </tr>
            <tr>
              <td class="p-1 p-sm-2">6</td>
              <td class="p-1 p-sm-2">I</td>
              <td class="p-1 p-sm-2">2</td>
              <td class="p-1 p-sm-2">-1</td>
              <td class="p-1 p-sm-2">StringBuilder[2].append(I)</td>
            </tr>
            <tr>
              <td class="p-1 p-sm-2">7</td>
              <td class="p-1 p-sm-2">S</td>
              <td class="p-1 p-sm-2">1</td>
              <td class="p-1 p-sm-2">-1</td>
              <td class="p-1 p-sm-2">StringBuilder[1].append(S)</td>
            </tr>
            <tr>
              <td class="p-1 p-sm-2">8</td>
              <td class="p-1 p-sm-2">H</td>
              <td class="p-1 p-sm-2">0</td>
              <td class="p-1 p-sm-2">1</td>
              <td class="p-1 p-sm-2">StringBuilder[0].append(H)</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</div>

<p>Sau đó loop array StringBuilder lúc đầu thì sẽ ra được kết quả.</p>

<p>Source code tham khảo: <a href="https://github.com/hoangdangduy/System_Patterns_Algorithm/tree/Master/Leetcode/src/_6_Zigzag_Conversion">https://github.com/hoangdangduy/System_Patterns_Algorithm/tree/Master/Leetcode/src/_6_Zigzag_Conversion</a></p>]]></content><author><name>hoangdd</name></author><category term="leet-code" /><category term="algorithm" /><summary type="html"><![CDATA[Bài toán: Chuyển đổi xâu theo dạng zigzag]]></summary></entry><entry><title type="html">Leet code 5: Tìm xâu đối xứng dài nhất</title><link href="/leet-code/algorithm/2025/05/18/leet-code-5-longest-palindromic-substring/" rel="alternate" type="text/html" title="Leet code 5: Tìm xâu đối xứng dài nhất" /><published>2025-05-18T15:40:00+00:00</published><updated>2025-05-18T15:40:00+00:00</updated><id>/leet-code/algorithm/2025/05/18/leet-code-5-longest-palindromic-substring</id><content type="html" xml:base="/leet-code/algorithm/2025/05/18/leet-code-5-longest-palindromic-substring/"><![CDATA[<p>Bài toán: Tìm xâu đối xứng dài nhất</p>

<p><a href="https://leetcode.com/problems/longest-palindromic-substring/description/">https://leetcode.com/problems/longest-palindromic-substring/description/</a></p>

<p>Ý tưởng giải quyết bài toán là ta sẽ coi các điểm cần duyệt trong xâu là điểm giữa của xâu đối xứng, sau đó sẽ phát triển duyệt sang 2 bên và check thêm các điều kiện để dừng.</p>

<p>Ví dụ với xâu <code class="language-plaintext highlighter-rouge">abcba</code> thì ta sẽ duyệt các bước như sau:</p>

<div class="container-fluid">
  <div class="row">
    <div class="col-12 col-md-8">
      <div class="table-responsive">
        <table class="table table-bordered">
          <thead>
            <tr>
              <th class="p-1 p-sm-2">Index</th>
              <th class="p-1 p-sm-2">0</th>
              <th class="p-1 p-sm-2">1</th>
              <th class="p-1 p-sm-2">2</th>
              <th class="p-1 p-sm-2">3</th>
              <th class="p-1 p-sm-2">4</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="p-1 p-sm-2">Character</td>
              <td class="p-1 p-sm-2">a</td>
              <td class="p-1 p-sm-2">b</td>
              <td class="p-1 p-sm-2">c</td>
              <td class="p-1 p-sm-2">b</td>
              <td class="p-1 p-sm-2">a</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</div>

<div class="container-fluid">
  <div class="row">
    <div class="col-12 col-md-10">
      <div class="table-responsive">
        <table class="table table-bordered">
          <thead>
            <tr>
              <th class="p-1 p-sm-2">Index</th>
              <th class="p-1 p-sm-2">start</th>
              <th class="p-1 p-sm-2">traverse left</th>
              <th class="p-1 p-sm-2">traverse right</th>
              <th class="p-1 p-sm-2">palindromic</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="p-1 p-sm-2">0</td>
              <td class="p-1 p-sm-2">a</td>
              <td class="p-1 p-sm-2">NULL</td>
              <td class="p-1 p-sm-2">b</td>
              <td class="p-1 p-sm-2">false</td>
            </tr>
            <tr>
              <td class="p-1 p-sm-2">1</td>
              <td class="p-1 p-sm-2">b</td>
              <td class="p-1 p-sm-2">a</td>
              <td class="p-1 p-sm-2">c</td>
              <td class="p-1 p-sm-2">false</td>
            </tr>
            <tr>
              <td class="p-1 p-sm-2">2</td>
              <td class="p-1 p-sm-2">c</td>
              <td class="p-1 p-sm-2">ab</td>
              <td class="p-1 p-sm-2">ba</td>
              <td class="p-1 p-sm-2">true</td>
            </tr>
            <tr>
              <td class="p-1 p-sm-2">3</td>
              <td class="p-1 p-sm-2">b</td>
              <td class="p-1 p-sm-2">c</td>
              <td class="p-1 p-sm-2">a</td>
              <td class="p-1 p-sm-2">false</td>
            </tr>
            <tr>
              <td class="p-1 p-sm-2">4</td>
              <td class="p-1 p-sm-2">a</td>
              <td class="p-1 p-sm-2">b</td>
              <td class="p-1 p-sm-2">NULL</td>
              <td class="p-1 p-sm-2">false</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</div>

<p>Xâu đối xứng dài nhất tìm được là <code class="language-plaintext highlighter-rouge">abcba</code></p>

<p>Với ví dụ trên ta sẽ triển khai được code giải thuật như sau:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">longestPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">longestPalindrome</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">longestPalindrome</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">longestPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="nc">String</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">left</span><span class="o">--;</span>
            <span class="n">right</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="n">left</span><span class="o">++;</span>
        <span class="n">right</span><span class="o">--;</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>Độ phức tạp của thuật toán là O(n^2)</p>

<p>Source code tham khảo: <a href="https://github.com/hoangdangduy/System_Patterns_Algorithm/blob/Master/Leetcode/src/_5_Longest_Palindromic_Substring/Solution.java">https://github.com/hoangdangduy/System_Patterns_Algorithm/blob/Master/Leetcode/src/_5_Longest_Palindromic_Substring/Solution.java</a></p>]]></content><author><name>hoangdd</name></author><category term="leet-code" /><category term="algorithm" /><summary type="html"><![CDATA[Bài toán: Tìm xâu đối xứng dài nhất]]></summary></entry><entry><title type="html">Leet code 4: Tính trung vị của 2 mảng đã được sắp xếp</title><link href="/leet-code/algorithm/2025/05/16/leet-code-4-median-of-two-sorted-arrays/" rel="alternate" type="text/html" title="Leet code 4: Tính trung vị của 2 mảng đã được sắp xếp" /><published>2025-05-16T17:29:00+00:00</published><updated>2025-05-16T17:29:00+00:00</updated><id>/leet-code/algorithm/2025/05/16/leet-code-4-median-of-two-sorted-arrays</id><content type="html" xml:base="/leet-code/algorithm/2025/05/16/leet-code-4-median-of-two-sorted-arrays/"><![CDATA[<p>Bài toán: Tìm giá trị trung vị của 2 mảng đã được sắp xếp</p>

<p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">https://leetcode.com/problems/median-of-two-sorted-arrays/</a></p>

<h2 id="1-tiếp-cận-bài-toán-hướng-đơn-giản">1. Tiếp cận bài toán hướng đơn giản</h2>

<p>Vì 2 mảng đã sắp xếp nên chúng ta có thể duyệt 2 mảng lần lượt từ trái qua phải hoặc từ phải qua trái, sau đó so sánh từng giá trị với nhau và lưu lại vào mảng mới.</p>

<p>Khi có mảng mới, nếu:</p>
<ul>
  <li>mảng có lẻ phần tử thì lấy <code class="language-plaintext highlighter-rouge">s3.length/2</code> là giá trị cần tìm.</li>
  <li>mảng có chẵn phần tử thì lấy <code class="language-plaintext highlighter-rouge">((s3.length/2 - 1) + s3.length/2) / 2</code> là giá trị cần tìm.</li>
</ul>

<p>Ta sẽ có được giải thuật như sau:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  i = s1.length - 1
  j = s2.length - 1
  
  s3 = [s1.length + s2.length]
  k = s3.length
  
  while (i &gt;= 0 &amp;&amp; j &gt;= 0) {
      if (s1[i] &gt; s2[j]) {
          s3[k] = s1[i];
          i--;
      } else {
          s3[k] = s1[j];
          j--;
      }
  }
  
  double result;
  if (s3.length % 2 == 0) {
      result = (s3[s3.length/2 - 1] + s3[s3.length/2]) / 2;
  } else {
      result = s3[s3.length/2];
  }
</code></pre></div></div>

<p>Với đoạn code trên ta có thể thấy i chạy từ <code class="language-plaintext highlighter-rouge">0 -&gt; s1.length</code>, j chạy từ <code class="language-plaintext highlighter-rouge">0 -&gt; s2.length</code> tức là độ phức tạp của thuật toán là O(max(n,m)) với n là độ dài của mảng s1 và m là độ dài của mảng s2.</p>

<h2 id="2-tiếp-cận-bài-toán-hướng-tối-ưu">2. Tiếp cận bài toán hướng tối ưu</h2>

<p>Vì 2 mảng này đã được sắp xếp rồi thì có thể áp dụng hướng tiếp cận binary search để chia mảng là 2 phần.</p>

<p>giả sử ta có mảng</p>

<div class="container-fluid">
  <div class="row">
    <div class="col-md-12 col-lg-10">
      <div class="table-responsive">
        <table class="table table-bordered">
          <thead>
            <tr>
              <th class="p-1 p-sm-2">index</th>
              <th class="p-1 p-sm-2">0</th>
              <th class="p-1 p-sm-2">1</th>
              <th class="p-1 p-sm-2">2</th>
              <th class="p-1 p-sm-2">3</th>
              <th class="p-1 p-sm-2">4</th>
              <th class="p-1 p-sm-2">5</th>
              <th class="p-1 p-sm-2">6</th>
              <th class="p-1 p-sm-2">7</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="p-1 p-sm-2">s1</td>
              <td class="p-1 p-sm-2">1</td>
              <td class="p-1 p-sm-2">3</td>
              <td class="p-1 p-sm-2">5</td>
              <td class="p-1 p-sm-2">6</td>
              <td class="p-1 p-sm-2">7</td>
              <td class="p-1 p-sm-2">9</td>
              <td class="p-1 p-sm-2"></td>
              <td class="p-1 p-sm-2"></td>
            </tr>
            <tr>
              <td class="p-1 p-sm-2">s2</td>
              <td class="p-1 p-sm-2">2</td>
              <td class="p-1 p-sm-2">3</td>
              <td class="p-1 p-sm-2">4</td>
              <td class="p-1 p-sm-2">4</td>
              <td class="p-1 p-sm-2">4</td>
              <td class="p-1 p-sm-2">8</td>
              <td class="p-1 p-sm-2">10</td>
              <td class="p-1 p-sm-2">12</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</div>

<p>Ta sẽ chia mảng s1 thành 2 phần với index vị trí giữa là partition1, mảng s2 thành 2 phần với index vị trí giữa là partition2.</p>

<p>Tạo sẵn biến:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">low = 0</code></li>
  <li><code class="language-plaintext highlighter-rouge">high = s1.length</code></li>
</ul>

<p>[A] Ta sẽ lấy:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">partition1 = (low + high) / 2</code> để chia mảng s1 thành 2 phần
    <ul>
      <li>partition1 = (0 + 6) / 2 = 3</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">partition2 = (s1.length + s2.length + 1) / 2 - partition1</code> để chia mảng s2 thành 2 phần
    <ul>
      <li>partition2 = (6 + 8 + 1) / 2 - 3 = 4</li>
    </ul>
  </li>
</ul>

<p>Ý tưởng là sẽ chia mảng <code class="language-plaintext highlighter-rouge">s1 ∪ s2</code> nên ở s1 đã lấy số lượng partition1 phần tử thì ở s2 lấy một nửa của <code class="language-plaintext highlighter-rouge">s1 ∪ s2</code> trừ đi số lượng partition1</p>

<p>Khi tìm được partition1 và partition2 ta sẽ kiểm tra giá trị của nó và lân cận nó so với vị trí ở mảng còn lại đã thoả mã 2 vị trí ở chính giữa chưa.</p>

<p>coi:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">maxLeft1 = s1[partition1 - 1] = s[3-1] = 5</code> là giá trị lớn nhất bên trái của partition1
    <ul>
      <li>mảng bên trái của s1: [1, 3, 5]</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">minRight1 = s1[partition1] = s[3] = 6</code> là giá trị nhỏ nhất bên phải của partition1
    <ul>
      <li>mảng bên phải của s1: [6, 7, 9]</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">maxLeft2 = s2[partition2 - 1] = s[4-1] = s[3] = 4</code> là giá trị lớn nhất bên trái của partition2
    <ul>
      <li>mảng bên trái của s2: [2, 3, 4, 4]</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">minRight2 = s2[partition2] = s[4] = 4</code> là giá trị nhỏ nhất bên phải của partition2
    <ul>
      <li>mảng bên phải của s2: [4, 8, 10, 12]</li>
    </ul>
  </li>
</ul>

<p>nếu:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">maxLeft1 &lt;= minRight2 &amp;&amp; maxLeft2 &lt;= minRight1</code> thì ta đã tìm được vị trí chia mảng</li>
  <li><code class="language-plaintext highlighter-rouge">maxLeft1 &gt; minRight2</code> tức là bên trái đang nhiều phần tử hơn, cần giảm partition1
    <ul>
      <li>set <code class="language-plaintext highlighter-rouge">high = partition1 - 1</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">maxLeft2 &gt; minRight1</code> tức là bên phải đang nhiều phần tử hơn, cần tăng partition1
    <ul>
      <li>set <code class="language-plaintext highlighter-rouge">low = partition1 + 1</code></li>
    </ul>
  </li>
</ul>

<p>Nếu chưa tìm được vị trí chia mảng thì quay lại bước [A] để tìm lại partition1 và partition2, ngược lại nhảy đến bước [B]</p>

<p>[B] Tính giá trị trung vị</p>
<ul>
  <li>Nếu số phần tử lẻ thì trả về max(maxLeft1, maxLeft2)</li>
  <li>Nếu số phần tử chẵn thì trả về (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2</li>
</ul>

<p>Áp dụng vào ví dụ trên ta có bảng các bước chi tiết như sau:</p>

<div class="container-fluid">
  <div class="row">
    <div class="col-md-12 col-lg-10">
      <div class="table-responsive">
        <table class="table table-bordered">
          <thead>
            <tr>
              <th class="p-1 p-sm-2"><b>step</b></th>
              <th class="p-1 p-sm-2"><b>low</b></th>
              <th class="p-1 p-sm-2"><b>high</b></th>
              <th class="p-1 p-sm-2"><b>partition1</b></th>
              <th class="p-1 p-sm-2"><b>partition2</b></th>
              <th class="p-1 p-sm-2"><b>left s1 ___ right s1</b></th>
              <th class="p-1 p-sm-2"><b>left s2 ___ right s2</b></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="p-1 p-sm-2">1</td>
              <td class="p-1 p-sm-2">0</td>
              <td class="p-1 p-sm-2">6</td>
              <td class="p-1 p-sm-2">3</td>
              <td class="p-1 p-sm-2">4</td>
              <td class="p-1 p-sm-2">1, 3, 5 ___ 6, 7, 9</td>
              <td class="p-1 p-sm-2">2, 3, 4, 4 ___ 4, 8, 10, 12</td>
            </tr>
            <tr>
              <td class="p-1 p-sm-2">2</td>
              <td class="p-1 p-sm-2">0</td>
              <td class="p-1 p-sm-2">2</td>
              <td class="p-1 p-sm-2">1</td>
              <td class="p-1 p-sm-2">6</td>
              <td class="p-1 p-sm-2">1 ___ 3, 5, 6, 7, 9</td>
              <td class="p-1 p-sm-2">2, 3, 4, 4, 4, 8 ___ 10, 12</td>
            </tr>
            <tr>
              <td class="p-1 p-sm-2">3</td>
              <td class="p-1 p-sm-2">2</td>
              <td class="p-1 p-sm-2">2</td>
              <td class="p-1 p-sm-2">2</td>
              <td class="p-1 p-sm-2">5</td>
              <td class="p-1 p-sm-2">1, 3 ___ 5, 6, 7, 9</td>
              <td class="p-1 p-sm-2">2, 3, 4, 4, 4 ___ 8, 10, 12</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</div>

<p>Từ các phân tích trên ta có đoạn code cụ thể như sau:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">findMedianSortedArrays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums1</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">findMedianSortedArrays</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">nums2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">findMedianSortedArrays</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">nums1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">findMedianSortedArrays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">s1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">s2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">partition1</span> <span class="o">=</span> <span class="o">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">partition2</span> <span class="o">=</span> <span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">partition1</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">maxLeft1</span> <span class="o">=</span> <span class="n">partition1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">maxLeft1</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span> <span class="o">:</span> <span class="n">s1</span><span class="o">[</span><span class="n">partition1</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">minRight1</span> <span class="o">=</span> <span class="n">partition1</span> <span class="o">&lt;</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span> <span class="o">?</span> <span class="n">s1</span><span class="o">[</span><span class="n">partition1</span><span class="o">]</span> <span class="o">:</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxLeft2</span> <span class="o">=</span> <span class="n">partition2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span> <span class="o">:</span> <span class="n">s2</span><span class="o">[</span><span class="n">partition2</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">minRight2</span> <span class="o">=</span> <span class="n">partition2</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span> <span class="o">?</span> <span class="n">s2</span><span class="o">[</span><span class="n">partition2</span><span class="o">]</span> <span class="o">:</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">maxLeft1</span> <span class="o">&gt;</span> <span class="n">minRight2</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">partition1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">return</span> <span class="nf">findMedianSortedArrays</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">high</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">maxLeft2</span> <span class="o">&gt;</span> <span class="n">minRight1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">partition1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">return</span> <span class="nf">findMedianSortedArrays</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">high</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLeft1</span><span class="o">,</span> <span class="n">maxLeft2</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">return</span> <span class="o">(</span><span class="kt">double</span><span class="o">)</span> <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLeft1</span><span class="o">,</span> <span class="n">maxLeft2</span><span class="o">)</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minRight1</span><span class="o">,</span> <span class="n">minRight2</span><span class="o">))</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>Vì áp dụng giải thuật binary search nên độ phức tạp chỉ là O(log(min(n,m))).</p>

<p>Source code tham khảo: <a href="https://github.com/hoangdangduy/System_Patterns_Algorithm/tree/Master/Leetcode/src/_4_Median_of_Two_Sorted_Arrays/">https://github.com/hoangdangduy/System_Patterns_Algorithm/tree/Master/Leetcode/src/_4_Median_of_Two_Sorted_Arrays</a></p>]]></content><author><name>hoangdd</name></author><category term="leet-code" /><category term="algorithm" /><summary type="html"><![CDATA[Bài toán: Tìm giá trị trung vị của 2 mảng đã được sắp xếp]]></summary></entry><entry><title type="html">Leet code 3: tìm độ dài xâu con dài nhất không bị trùng lặp</title><link href="/leet-code/algorithm/2025/05/10/leet-code-3-sliding-window/" rel="alternate" type="text/html" title="Leet code 3: tìm độ dài xâu con dài nhất không bị trùng lặp" /><published>2025-05-10T14:16:00+00:00</published><updated>2025-05-10T14:16:00+00:00</updated><id>/leet-code/algorithm/2025/05/10/leet-code-3-sliding-window</id><content type="html" xml:base="/leet-code/algorithm/2025/05/10/leet-code-3-sliding-window/"><![CDATA[<p>Bài toán: Tìm độ dài xâu con dài nhất không bị trùng lặp</p>

<p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a></p>

<p>Giả sử có string <strong>s</strong> là <strong>abcabccbc</strong>, chúng ta cần phải tìm độ dài của xâu con dài nhất không bị trùng lặp.</p>

<p>Tiếp cận bài toán này chúng ta có thể áp dụng giải thuật sliding window + hash map với độ phức tạp là O(n) với n là độ dài của string.</p>

<p>Các bước phân tích lời giải bài toán:</p>
<ul>
  <li>Cần lưu được độ dài của xâu đang xét nên chúng ta cần biến left và right để xác định xâu con</li>
  <li>Sử dụng map để lưu lại vị trí của các ký tự trong xâu</li>
  <li>Giá trị độ dài lớn nhất của xâu con</li>
</ul>

<div class="container-fluid">
    <div class="row">
      <div class="col-md-12 col-lg-6">
        <div class="table-responsive">
          <table class="table table-bordered">
            <thead>
              <tr>
                <th class="p-1 p-sm-2">Character</th>
                <th class="p-1 p-sm-2">a</th>
                <th class="p-1 p-sm-2">b</th>
                <th class="p-1 p-sm-2">c</th>
                <th class="p-1 p-sm-2">a</th>
                <th class="p-1 p-sm-2">b</th>
                <th class="p-1 p-sm-2">c</th>
                <th class="p-1 p-sm-2">c</th>
                <th class="p-1 p-sm-2">b</th>
                <th class="p-1 p-sm-2">c</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="p-1 p-sm-2">Index</td>
                <td class="p-1 p-sm-2">0</td>
                <td class="p-1 p-sm-2">1</td>
                <td class="p-1 p-sm-2">2</td>
                <td class="p-1 p-sm-2">3</td>
                <td class="p-1 p-sm-2">4</td>
                <td class="p-1 p-sm-2">5</td>
                <td class="p-1 p-sm-2">6</td>
                <td class="p-1 p-sm-2">7</td>
                <td class="p-1 p-sm-2">8</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

<div class="container-fluid">
    <div class="row">
      <div class="col-md-12 col-lg-6">
        <div class="table-responsive">
          <table class="table table-bordered">
            <thead>
              <tr>
                <th class="p-1 p-sm-2">Step</th>
                <th class="p-1 p-sm-2">Left</th>
                <th class="p-1 p-sm-2">Right</th>
                <th class="p-1 p-sm-2">Map</th>
                <th class="p-1 p-sm-2">Length</th>
                <th class="p-1 p-sm-2">Sub string</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="p-1 p-sm-2">0</td>
                <td class="p-1 p-sm-2"></td>
                <td class="p-1 p-sm-2"></td>
                <td class="p-1 p-sm-2"></td>
                <td class="p-1 p-sm-2">0</td>
                <td class="p-1 p-sm-2"></td>
              </tr>
              <tr>
                <td class="p-1 p-sm-2">1</td>
                <td class="p-1 p-sm-2">0</td>
                <td class="p-1 p-sm-2">0</td>
                <td class="p-1 p-sm-2">a:0</td>
                <td class="p-1 p-sm-2">1</td>
                <td class="p-1 p-sm-2">a</td>
              </tr>
              <tr>
                <td class="p-1 p-sm-2">2</td>
                <td class="p-1 p-sm-2">0</td>
                <td class="p-1 p-sm-2">1</td>
                <td class="p-1 p-sm-2">a:0; b:1</td>
                <td class="p-1 p-sm-2">2</td>
                <td class="p-1 p-sm-2">ab</td>
              </tr>
              <tr>
                <td class="p-1 p-sm-2">3</td>
                <td class="p-1 p-sm-2">0</td>
                <td class="p-1 p-sm-2">2</td>
                <td class="p-1 p-sm-2">a:0; b:1; c:2</td>
                <td class="p-1 p-sm-2">3</td>
                <td class="p-1 p-sm-2">abc</td>
              </tr>
              <tr>
                <td class="p-1 p-sm-2">4</td>
                <td class="p-1 p-sm-2">0</td>
                <td class="p-1 p-sm-2">3</td>
                <td class="p-1 p-sm-2">a:3; b:1; c:2</td>
                <td class="p-1 p-sm-2">3</td>
                <td class="p-1 p-sm-2">bca</td>
              </tr>
              <tr>
                <td class="p-1 p-sm-2">5</td>
                <td class="p-1 p-sm-2">1</td>
                <td class="p-1 p-sm-2">4</td>
                <td class="p-1 p-sm-2">a:3; b:4; c:2</td>
                <td class="p-1 p-sm-2">3</td>
                <td class="p-1 p-sm-2">cab</td>
              </tr>
              <tr>
                <td class="p-1 p-sm-2">6</td>
                <td class="p-1 p-sm-2">2</td>
                <td class="p-1 p-sm-2">5</td>
                <td class="p-1 p-sm-2">a:3; b:4; c:5</td>
                <td class="p-1 p-sm-2">3</td>
                <td class="p-1 p-sm-2">abc</td>
              </tr>
              <tr>
                <td class="p-1 p-sm-2">7</td>
                <td class="p-1 p-sm-2">5</td>
                <td class="p-1 p-sm-2">6</td>
                <td class="p-1 p-sm-2">a:3; b:4; c:6</td>
                <td class="p-1 p-sm-2">1</td>
                <td class="p-1 p-sm-2">c</td>
              </tr>
              <tr>
                <td class="p-1 p-sm-2">8</td>
                <td class="p-1 p-sm-2">6</td>
                <td class="p-1 p-sm-2">7</td>
                <td class="p-1 p-sm-2">a:3; b:7; c:6</td>
                <td class="p-1 p-sm-2">2</td>
                <td class="p-1 p-sm-2">cb</td>
              </tr>
              <tr>
                <td class="p-1 p-sm-2">9</td>
                <td class="p-1 p-sm-2">6</td>
                <td class="p-1 p-sm-2">8</td>
                <td class="p-1 p-sm-2">a:3; b:7; c:8</td>
                <td class="p-1 p-sm-2">2</td>
                <td class="p-1 p-sm-2">bc</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

<p>Giải thuật:</p>
<ul>
  <li>loop: right chạy từ 0 -&gt; s.length
    <ul>
      <li>check s[right] có trong map và map chứa s[right] &gt;= left (tức là s[right] đang nằm trong xâu con đang xét s[left:right])
        <ul>
          <li>đúng:
            <ul>
              <li>left = map[s[right]] + 1 để tiếp tục xét từ vị trí tiếp theo của s[right] trong map</li>
              <li>length = right - map[s[right]] cập nhật lại length của s[left:right]</li>
            </ul>
          </li>
          <li>sai:
            <ul>
              <li>length = right - left + 1</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>cập nhật s[right] với vị trí right vào map</li>
      <li>right tăng lên 1</li>
    </ul>
  </li>
</ul>

<p>Triển khai giải thuật trên ta có được code như sau:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">))</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">))</span> <span class="o">&gt;=</span> <span class="n">left</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">));</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">))</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">),</span> <span class="n">right</span><span class="o">);</span>
        <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">length</span><span class="o">);</span>

        <span class="n">right</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Tối ưu để clean code</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">left</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
        <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">right</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Khi đến đây bạn đã giải quyết được bài toán rồi.</p>

<p>Hãy giải quyết thêm các bài toán khác để nâng cao kỹ năng thuật toán nhé.</p>]]></content><author><name>hoangdd</name></author><category term="leet-code" /><category term="algorithm" /><summary type="html"><![CDATA[Bài toán: Tìm độ dài xâu con dài nhất không bị trùng lặp]]></summary></entry><entry><title type="html">Linked list</title><link href="/data-structure/2025/05/10/linked-list/" rel="alternate" type="text/html" title="Linked list" /><published>2025-05-10T14:16:00+00:00</published><updated>2025-05-10T14:16:00+00:00</updated><id>/data-structure/2025/05/10/linked-list</id><content type="html" xml:base="/data-structure/2025/05/10/linked-list/"><![CDATA[<ol>
  <li>
    <p>Đặt câu hỏi: Linked list là gì?
Trả lời: Linked list là cấu trúc dữ liệu mô tả tính liên kết của phần tử thông qua vị trí tham chiếu trên bộ nhớ giúp cho việc thêm/xoá phần tử rất linh hoạt mà không tốn thêm nhiều bộ nhớ.</p>
  </li>
  <li>
    <p>Có 2 loại linked list:</p>
    <ul>
      <li>Liên kết đơn (singly linked list): mỗi node sẽ có 1 con trỏ đến node tiếp theo</li>
    </ul>
  </li>
</ol>
<div style="text-align: center;">
  <img src="/assets/images/linked-list/single-linked-list.png" alt="single-linked-list" class="img-fluid" />
  <p class="text-muted">Hình 1: Liên kết đơn</p>
</div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LinkedList</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">key</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">LinkedList</span> <span class="n">next</span><span class="o">;</span>

    <span class="c1">// ignore getter and setter, constructor</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>Liên kết đôi (doubly linked list): mỗi node sẽ có 2 con trỏ đến node trước và node sau</li>
</ul>
<div style="text-align: center;">
  <img src="/assets/images/linked-list/double-linked-list.png" alt="double-linked-list" class="img-fluid" />
  <p class="text-muted">Hình 2: Liên kết đôi</p>
</div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LinkedList</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">key</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">LinkedList</span> <span class="n">next</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">LinkedList</span> <span class="n">prev</span><span class="o">;</span>

    <span class="c1">// ignore getter and setter, constructor</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Ưu điểm:</p>
<ul>
  <li>Không tốn bộ nhớ cho việc liên kết giữa các node như dùng mảng bởi vì nó chỉ dùng bộ nhớ để lưu con trỏ, còn mảng thì dùng bộ nhớ để lưu cả mảng.</li>
  <li>Độ phức tạp O(1) cho việc thêm vào và O(n) cho việc tìm kiếm</li>
</ul>

<p>Nhược điểm:</p>
<ul>
  <li>Không truy cập nhanh đến các node, phải duyệt lần lượt với độ phức tạp là O(n)</li>
</ul>

<ol>
  <li>Các dạng bài toán áp dụng được linked list:</li>
</ol>

<p>3.1. Triển khi stack <a href="https://github.com/hoangdangduy/System_Patterns_Algorithm/tree/Master/Book/Introduction_To_Algorithms/src/_10_2_2">[Tham khảo source code]</a></p>
<div style="text-align: center;">
  <img src="/assets/images/linked-list/stack.png" alt="stack" class="img-fluid" />
  <p class="text-muted">Hình 3: Stack</p>
</div>
<ul>
  <li>Con trỏ head luôn ở đầu bất kể phần tử nào được thêm mới vào. Mỗi phân từ sau được thêm vào sẽ luôn là head và trỏ đến phần tử vào trước nó (phần tử tiếp theo)</li>
</ul>

<p>3.2. Triển khai queue <a href="https://github.com/hoangdangduy/System_Patterns_Algorithm/tree/Master/Book/Introduction_To_Algorithms/src/_10_2_3">[Tham khảo source code]</a></p>
<div style="text-align: center;">
  <img src="/assets/images/linked-list/queue.png" alt="queue" class="img-fluid" />
  <p class="text-muted">Hình 4: Queue</p>
</div>
<ul>
  <li>Con trỏ head và tail luôn ở 2 đầu để queue lấy được ở cả 2 đầu</li>
</ul>

<p>3.3. Triển khai doubly linked list bằng toán tử XOR <a href="https://github.com/hoangdangduy/System_Patterns_Algorithm/tree/Master/Book/Introduction_To_Algorithms/src/_10_2_6">[Tham khảo source code]</a></p>

<p>3.4. Các bài toán tham khảo khác:</p>
<ul>
  <li><a href="https://leetcode.com/problems/add-two-numbers/description/">Leet code: Add Two Numbers</a>
    <ul>
      <li><a href="https://github.com/hoangdangduy/System_Patterns_Algorithm/tree/Master/Leetcode/src/_2_Add_Two_Number">Đáp án</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>hoangdd</name></author><category term="data-structure" /><summary type="html"><![CDATA[Đặt câu hỏi: Linked list là gì? Trả lời: Linked list là cấu trúc dữ liệu mô tả tính liên kết của phần tử thông qua vị trí tham chiếu trên bộ nhớ giúp cho việc thêm/xoá phần tử rất linh hoạt mà không tốn thêm nhiều bộ nhớ.]]></summary></entry><entry><title type="html">Thiết kế lưu trữ dữ liệu phân tán với Consistency Hashing</title><link href="/design-system/2025/04/19/consistency-hashing/" rel="alternate" type="text/html" title="Thiết kế lưu trữ dữ liệu phân tán với Consistency Hashing" /><published>2025-04-19T08:40:00+00:00</published><updated>2025-04-19T08:40:00+00:00</updated><id>/design-system/2025/04/19/consistency-hashing</id><content type="html" xml:base="/design-system/2025/04/19/consistency-hashing/"><![CDATA[<p>Việc lưu trữ dữ liệu dạng single server hay còn gọi monolitic là một cách tiếp cận đơn giản và dễ dàng để triển khai. Tuy nhiên, khi dữ liệu ngày càng lớn, việc mở rộng quy mô trở thành một thách thức lớn, vậy làm sao để làm giảm công việc chỉnh sửa lại vị trí lưu dữ liệu khi tăng/giảm số server? Để giải quyết vấn đề này, chúng ta cần một cách tiếp cận phân tán hơn, cho phép chúng ta mở rộng quy mô mà không làm giảm hiệu suất. Do đó, consistency hashing là một trong nhiều cách tiếp cận để giải quyết bài toán đó.</p>

<p>Đầu tiên chúng ta cần phải hiểu consistency hashing là gì?</p>

<p>Consistency hashing là cách triển khai hash (băm) các giá trị theo cách thống nhất để lưu trữ và nhận dữ liệu hiệu quả.</p>

<p>Giả sử chúng ta có 3 server có tên là s1, s2 và s3.</p>

<div style="text-align: center;">
  <img src="/assets/images/consistency-hashing/consitency-hashing-1.png" alt="consitency-hashing-1" class="img-fluid" />
  <p class="text-muted">Hình 1: Mô hình triển khai</p>
</div>

<p>Thêm 3 server vào hệ thống để lưu trữ dữ liệu</p>

<p>Mỗi server sẽ có 1 giá trị hash khác nhau, ta sẽ quy ước là hash(server), có thể lấy địa chỉ IP của server miễn sao đảm bảo nó là duy nhất.</p>

<p>Khi dữ liệu được insert vào server thì chúng cũng sẽ được hash(data) và so sánh với value hash của server. Ta sẽ tìm được server có giá trị hash gần với hash(data) nhất.</p>

<p>Ví dụ:</p>
<ul>
  <li>hash server:
    <ul>
      <li>hash(s1) = 10</li>
      <li>hash(s2) = 20</li>
      <li>hash(s3) = 30</li>
    </ul>
  </li>
  <li>hash data:
    <ul>
      <li>hash(x) = 15</li>
      <li>hash(y) = 17</li>
      <li>hash(z) = 25
Ta sẽ lưu được x và y vào s2, z vào s3.</li>
    </ul>
  </li>
</ul>

<div style="text-align: center;">
  <img src="/assets/images/consistency-hashing/consitency-hashing-2.png" alt="consitency-hashing-2" class="img-fluid" />
  <p class="text-muted">Hình 2: Phân phối dữ liệu vào server</p>
</div>

<h3 id="example-code">Example code:</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Lưu dữ liệu vào server</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">saveData</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="nc">String</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">getNode</span><span class="o">(</span><span class="n">key</span><span class="o">).</span><span class="na">getDataStore</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// Tìm ra server đã lưu dữ liệu</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">Storage</span> <span class="nf">getNode</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">var</span> <span class="n">hash</span> <span class="o">=</span> <span class="nc">HashingStrategy</span><span class="o">.</span><span class="na">generateHash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="o">=</span> <span class="n">mapConsistencyHashing</span><span class="o">.</span><span class="na">tailMap</span><span class="o">(</span><span class="n">hash</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">map</span> <span class="o">=</span> <span class="n">mapConsistencyHashing</span><span class="o">.</span><span class="na">headMap</span><span class="o">(</span><span class="n">hash</span><span class="o">);</span>
        <span class="kt">var</span> <span class="n">firstKey</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">firstKey</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">firstKey</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kt">var</span> <span class="n">firstKey</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">firstKey</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">firstKey</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Như ví dụ ở trên, chúng ta thấy s1 thì không có dữ liệu nào được lưu trữ vào còn s2 lại lưu cả x và y. Để giải quyết vấn đề này chúng ta sẽ thêm các node ảo của server gọi là virtual node để tăng xác suất lưu trữ đều vào các server vật lý, tránh tập trung lưu trữ chỉ tại một nơi.</p>

<p>Mỗi server sẽ tạo thành 2 virtual node và hash(virtual_node) như cách làm với server.
Ta sẽ có:</p>
<ul>
  <li>hash virtual node của s1
    <ul>
      <li>hash(s1_v1) = 11</li>
      <li>hash(s1_v2) = 16</li>
    </ul>
  </li>
  <li>hash virtual node của s2</li>
  <li>
    <ul>
      <li>hash(s2_v1) = 21</li>
      <li>hash(s2_v2) = 24</li>
    </ul>
  </li>
  <li>hash virtual node của s3</li>
  <li>
    <ul>
      <li>hash(s3_v1) = 26</li>
      <li>hash(s3_v2) = 31</li>
    </ul>
  </li>
</ul>

<p>Sau khi có virtual node thì dữ liệu sẽ được phân phối lại như sau:</p>

<div style="text-align: center;">
  <img src="/assets/images/consistency-hashing/consitency-hashing-3.png" alt="consitency-hashing-3" class="img-fluid" />
  <p class="text-muted">Hình 3: Phân phối dữ liệu sau khi thêm virtual node</p>
</div>

<h3 id="example-code-1">Example code:</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Khởi tạo các server</span>
<span class="nc">ConsistencyHashing</span><span class="o">.</span><span class="na">addServer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Storage</span><span class="o">(</span><span class="s">"server-1"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ConcurrentHashMap</span><span class="o">&lt;&gt;()));</span>
<span class="nc">ConsistencyHashing</span><span class="o">.</span><span class="na">addServer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Storage</span><span class="o">(</span><span class="s">"server-2"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ConcurrentHashMap</span><span class="o">&lt;&gt;()));</span>
<span class="nc">ConsistencyHashing</span><span class="o">.</span><span class="na">addServer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Storage</span><span class="o">(</span><span class="s">"server-3"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ConcurrentHashMap</span><span class="o">&lt;&gt;()));</span>

<span class="c1">// Mỗi server vật lý sẽ chuyển sang tạo virtual node tương ứng</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">addServer</span><span class="o">(</span><span class="nc">Storage</span> <span class="n">storage</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">VIRTUAL_NODE</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">hash</span> <span class="o">=</span> <span class="nc">HashingStrategy</span><span class="o">.</span><span class="na">generateHash</span><span class="o">(</span><span class="n">storage</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">concat</span><span class="o">(</span><span class="s">"-"</span><span class="o">).</span><span class="na">concat</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">i</span><span class="o">)));</span>
        <span class="n">mapConsistencyHashing</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">storage</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Như vậy với ý tưởng này chúng ta đã giải quyết được cách lưu trữ dữ liệu trong hệ thống phân tán.</p>

<p>Để hiểu cách thức triển khai và nắm rõ hơn về cách áp dụng thì các bạn có thể suy nghĩ thêm các câu hỏi mở rộng:</p>
<ul>
  <li>Khi thêm 1 server mới vào mô hình trên thì các dữ liệu đã được gán vào server cũ sẽ phân phối lại như nào?</li>
  <li>Từ 1 server vật lý thì tạo ra bao nhiêu virtual node tương ứng là đủ?</li>
</ul>

<p>Source code tham khảo: <a href="https://github.com/hoangdangduy/System_Patterns_Algorithm/tree/Master/consistency_hashing">https://github.com/hoangdangduy/System_Patterns_Algorithm/tree/Master/consistency_hashing</a></p>]]></content><author><name>hoangdd</name></author><category term="design-system" /><summary type="html"><![CDATA[Việc lưu trữ dữ liệu dạng single server hay còn gọi monolitic là một cách tiếp cận đơn giản và dễ dàng để triển khai. Tuy nhiên, khi dữ liệu ngày càng lớn, việc mở rộng quy mô trở thành một thách thức lớn, vậy làm sao để làm giảm công việc chỉnh sửa lại vị trí lưu dữ liệu khi tăng/giảm số server? Để giải quyết vấn đề này, chúng ta cần một cách tiếp cận phân tán hơn, cho phép chúng ta mở rộng quy mô mà không làm giảm hiệu suất. Do đó, consistency hashing là một trong nhiều cách tiếp cận để giải quyết bài toán đó.]]></summary></entry></feed>